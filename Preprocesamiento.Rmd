---
title: "La población carcelaria en Colombia 1991-2017"
author: "Sergio Solano"
date: "Febrero de 2016"
output:
  pdf_document: default
  word_document: default
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```

## Data 

El INPEC publica mensualemente la serie población carcelaria, desde 1991 hasta el mese anterior a la publicación. Esta serie se encuentra separada por situación jurídica (condenados, sindicados) y por genero. 

## Objetivo

El proceso a través del cual las personas pasan de una situación jurídica a otra es conocido, y sin embargo no observado, pues no se publican las series de tiempo que reflejan esta transición (cantidad de personas sentenciadas por mes, cantidad de personas liberadas mes, duración de la condena). 

Este ejercicio de demografía, enmarcado en el estudio de poblaciones pequeñas, presenta la oportunidad de comparar la efectividad de diferentes métodos de proyección.

# Análisis exploratorio

La población carcelaria total entre 1991 y 2017 se ha cuadruplicado, al pasar de 32.036 a 128.125 internos. Aunque la mayoría son hombres la población carcelaria feminina en el mismo periodo ha crecido a una tasa mayor, pues se ha multiplicado por cinco, de 1633 en 1991 a 7800 en 2017.

```{r librerías, echo = FALSE, include=FALSE }
rm(list = ls())
library("magrittr") # Data handling
library("tidyr") # Data handling
library("reshape2") # Data handling
library("dplyr") # Data handling
library("curl") # Data downloading

library("ggplot2") # gráficas
library("plotly") # gráficas
library("gridExtra") # gráficas
library("RColorBrewer") # Gráficas
library("colorRamps") # Gráficas

library("zoo") # Handling tss
library("timeSeries") # ts

library("xtable") # Tablas
library("shiny") # apps

library("xts") # ts
library ("vars") # ts

library("astsa") # Estimar ts # instalar versión 1.7
#require(devtools)
#install_version("astsa", version = "1.7")

library("forecast") # Estimar ts

library("rms") #regression
```

```{r carga de datos, echo = FALSE, include=FALSE }
# Carga de archivos base
url <- "https://www.dropbox.com/s/epb2srm6pglyz9w/PPL_SITJUR_ENE17.csv?dl=1"
destfile <- "POB_SITJUR_INP_ENE17.csv"
curl_download(url, destfile)
data = read.csv("POB_SITJUR_INP_ENE17.csv",header = TRUE,sep = ",",stringsAsFactors=FALSE)

```


```{r forma de los datos, echo = FALSE, include=FALSE }

# Carga de archivos base Situación judicial
ppl_sitjur_ene17 <- (data[2:13,2:dim(data)[2]])
ppl_sitjur <- cbind(gather(ppl_sitjur_ene17)[2],rep(c(rep("sindicados",12), rep("condenados",12), rep("total",12)),dim(ppl_sitjur_ene17)[2]/3))
colnames(ppl_sitjur) <- c("valor", "categoria")
ppl_sitjur$valor <- as.numeric(ppl_sitjur$valor)*1000
anio <- sort(rep(seq(1991,1991+dim(ppl_sitjur_ene17)[2]/3-1,by =1),36))
mes <- rep(seq(1,12,1),dim(ppl_sitjur_ene17)[2])
ppl_sitjur <- cbind(ppl_sitjur,anio, mes) 
# ppl_sitjur  %<>% spread(key = "categoria", value = valor) 

ppl_sitjur %<>% mutate (Fecha = as.Date(paste (1,mes,anio, sep = "/"),"%d/%m/%Y")) 
```


```{r sit_jur, echo = FALSE}

ppl_sitjur %>% dplyr::filter(categoria %in% c("sindicados","condenados","total"), valor >0) %>%  ggplot() + geom_line(aes(x=Fecha,y = valor, colour = categoria),stat = "identity") + ylab("Personas privadas de la libertad") + theme_minimal()-> grafica 
ppl_sitjur %>% dplyr::filter(categoria %in% c("sindicados","condenados","total"), valor >0) %>%  ggplot() + geom_line(aes(x=Fecha,y = valor, colour = categoria),stat = "identity") + ylab("Personas privadas de la libertad") + theme_minimal() + theme(legend.title = element_blank())-> grafica 
# ggplotly(grafica)
grafica
ggsave("sit_jur.png")
```


```{r carga de datos - genero, echo = FALSE, include=FALSE }
# Carga de archivos base
url <- "https://www.dropbox.com/s/95m8oziipdy6ely/PPL_GEN_ENE17.csv?dl=1"
destfile <- "POB_GEN_INP_ENE17.csv"
curl_download(url, destfile)
data = read.csv("POB_GEN_INP_ENE17.csv",header = TRUE,sep = ",",stringsAsFactors=FALSE)

```


```{r forma de los datos - genero, echo = FALSE, include=FALSE }

# Carga de archivos base genero
ppl_gen_ene17 <- (data[2:13,2:dim(data)[2]])
ppl_gen <- cbind(gather(ppl_gen_ene17)[2],rep(c(rep("hombres",12), rep("mujeres",12), rep("total",12)),dim(ppl_sitjur_ene17)[2]/3))
colnames(ppl_gen) <- c("valor", "categoria")
ppl_gen$valor <- as.numeric(ppl_gen$valor)*1000
anio <- sort(rep(seq(1991,1991+dim(ppl_sitjur_ene17)[2]/3-1,by =1),36))
mes <- rep(seq(1,12,1),dim(ppl_sitjur_ene17)[2])
ppl_gen <- cbind(ppl_gen,anio, mes) 

ppl_gen %<>% mutate (Fecha = as.Date(paste (1,mes,anio, sep = "/"),"%d/%m/%Y")) 
```


```{r genero, echo = FALSE}

ppl_gen %>% dplyr::filter (categoria %in% c("hombres","mujeres","total"), valor >0) %>%  ggplot() + geom_line(aes(x=Fecha,y = valor, colour = categoria),stat = "identity") + ylab("Personas privadas de la libertad") + theme_minimal() + theme(legend.title = element_blank()) -> grafica 
# ggplotly(grafica)
 grafica
 ggsave("genero.png")
```

```{r Estimación Población Nacional, include = TRUE, echo = FALSE, warning = FALSE, message=FALSE}


url <- "https://www.dropbox.com/s/54vmiq6tfhor0t1/POB_NAL_DANE.csv?dl=1"
destfile <- "POB_NAL_DAN.csv"
curl_download(url, destfile)

# setwd("/home/sergio/Prisiones") 
data = read.csv("POB_NAL_DAN.csv",header = TRUE,sep = ",",stringsAsFactors=FALSE)

# reordenar columnas por sexo
data %>% spread(Grupo, Total, fill = NA, convert = FALSE) %>% mutate(tasa_hombres = c(log(Hombres[2:length(Hombres)]/Hombres[1:length(Hombres)-1]),1))%>% mutate(tasa_mujeres = c(log(Mujeres[2:length(Mujeres)]/Mujeres[1:length(Mujeres)-1]),1))%>% mutate(Fecha=as.Date(paste("01","06",Año,sep="/"),"%d/%m/%Y"))   -> data2

# Proyectar población a nivel mensual 

ts_pob_nal_hom <- zoo(data2$Hombres,data2$Fecha)  
ts_pob_nal_hom_mon <- na.spline(ts_pob_nal_hom, xout = seq(start(ts_pob_nal_hom),as.Date(as.yearqtr(end(ts_pob_nal_hom))+ 3/4) , by = "month"), method = "hyman")

ts_pob_nal_muj <- zoo(data2$Mujeres,data2$Fecha)  
ts_pob_nal_muj_mon <- na.spline(ts_pob_nal_muj, xout = seq(start(ts_pob_nal_muj),as.Date(as.yearqtr(end(ts_pob_nal_muj))+ 3/4) , by = "month"), method = "fmm")
                                
pob_nal_est <- cbind(seq(as.Date("1985/6/1"), as.Date("2021/1/1"), "months"), as.data.frame.ts(ts_pob_nal_hom_mon),as.data.frame.ts(ts_pob_nal_muj_mon)) 

colnames(pob_nal_est) <- c("Fecha","hombres_nac","mujeres_nac")

pob_nal_est %<>% mutate (total_nac = hombres_nac + mujeres_nac)


```
El incremento en la población carcelaria podría tomarse como un efecto del crecimiento de la población colombiana. Para validar este supuesto calculamos la tasa de encarcelamiento, que mide la cantidad de personas encarceladas por cada cien mil habitantes. Este indicador pasó de 92 personas por cada cien mil habitantes en enero de 1991 a 242 en enero de 2016. Tal incremento se puede ver tanto en hombres como en mujeres.

```{r tasas, echo = FALSE,  warning = FALSE, message=FALSE}

ppl_gen  %<>% spread(key = "categoria", value = valor) 

ppl_tasa <- left_join(pob_nal_est,ppl_gen, by = "Fecha") %>% mutate (tasa_hombres = hombres/hombres_nac * 100000, tasa_mujeres = mujeres/mujeres_nac * 100000, tasa_total = total/total_nac*100000) 

ppl_tasa %>% ggplot() + geom_line(aes(x=Fecha,y=tasa_hombres,colour="Hombres")) +geom_line(aes(x=Fecha,y=tasa_mujeres,colour="Mujeres"))+geom_line(aes(x=Fecha,y=tasa_total,colour="Total")) + expand_limits(y=0) + ylab("Tasa de encarcelamiento") +theme_minimal() + theme(legend.title = element_blank())-> tasas_encarcelamiento
# ggplotly (tasas_encarcelamiento)
tasas_encarcelamiento
ggsave("tasas.png")
```

La tasa de encarcelamiento ha crecido de forma exponencial, tanto en hombres como en mujeres, y  se puede ver en la gráfica siguiente.

```{r tasa_log, echo = FALSE,  warning = FALSE, message=FALSE}
ppl_tasa %>% ggplot() + geom_line(aes(x=Fecha,y=tasa_hombres,colour="Hombres")) +geom_line(aes(x=Fecha,y=tasa_mujeres,colour="Mujeres"))+geom_line(aes(x=Fecha,y=tasa_total,colour="Total")) + expand_limits(y=0) + scale_y_log10 (breaks = c(10,50,100,200,400)) + ylab("Tasa de encarcelamiento") + theme_minimal() + theme(legend.title = element_blank())-> tasas_encarcelamiento_log
# ggplotly (tasas_encarcelamiento_log)

tasas_encarcelamiento_log
ggsave("tasas_log.png")
```

## Crecimiento de la Población Privada de la Libertad (PPL)

Una primera aproximación al análisis de la población carcelaria, se podría realizar al separar los componentes estacionales, de tendencia y aleatorios de la serie de tiempo. No obstante, es posible inferir que la variabilidad de la serie no es constante. Por esta razón resultaría pertinente analizar la tasa de crecimiento de la población de mes a mes. Una técnica comunmente usada es trabajar con la difencia de los logaritmos de la población, que para variaciones cercanas a cero, se aproxima a la tasa de crecimiento. 


```{r graf_crecimiento, echo = FALSE,  warning = FALSE, message=FALSE}
# ajustar población sindicada y condenada para análisis
MPPtimeseries <- ts(ppl_gen$total, frequency=12, start=c(1991,1))

autoplot(as.zoo(diff(log(MPPtimeseries))), geom = "line") + ylab("tasa de crecimiento- PPL total") + xlab("Periodo")  +theme_minimal() -> graf_crecimiento
graf_crecimiento
#ggplotly(graf_crecimiento)

```


```{r desc_total, echo = FALSE,  warning = FALSE, message=FALSE }
DeltaMPP <- decompose(diff(MPPtimeseries))

tendencia <- as.zoo(DeltaMPP$trend)
aleatorio <- as.zoo(DeltaMPP$random)
estacional <- as.zoo(DeltaMPP$seasonal)

autoplot(merge(tendencia,estacional, aleatorio), geom = "line") + ylab("tasa de crecimiento - descomposición") + xlab("Periodo") + theme_minimal()  -> graf_tendencia
graf_tendencia       
# ggplotly(graf_tendencia)
ggsave("desc_total.png")
```




```{r tasa crecimiento, echo = FALSE,  warning = FALSE, message=FALSE}

MPPtimeseries <- ts(ppl_gen$total, frequency=12, start=c(1991,1))

autoplot(as.zoo(diff(log(MPPtimeseries))), geom = "line") + ylab("tasa de crecimiento- PPL total") + xlab("Periodo")  -> graf_crecimiento
graf_crecimiento
# ggplotly(graf_crecimiento)

```

Crecimiento de la población privada de la libertad masculida

```{r tasa crecimiento masculina, echo = FALSE,  warning = FALSE, message=FALSE}

MPPtimeseries <- ts(ppl_gen$hombres, frequency=12, start=c(1991,1))

autoplot(as.zoo(diff(log(MPPtimeseries))), geom = "line") + ylab("tasa de crecimiento- PPL masculina") + xlab("Periodo") + theme_minimal() + theme(aspect.ratio=1/2, legend.title = element_blank()) -> graf_crecimiento

graf_crecimiento
ggsave("crec_masc.png")
# ggplotly(graf_crecimiento)

```

```{r tend_masc_desc, echo = FALSE,  warning = FALSE, message=FALSE }
DeltaMPP <- decompose(diff(log(MPPtimeseries)))

tendencia <- as.zoo(DeltaMPP$trend)
aleatorio <- as.zoo(DeltaMPP$random)
estacional <- as.zoo(DeltaMPP$seasonal)

autoplot(merge(tendencia,estacional, aleatorio), geom = "line") + ylab("tasa de crecimiento masculina- descomposición") + xlab("Periodo") + theme_minimal() -> graf_tendencia
graf_tendencia
ggsave("tend_masc_desc.png")
# ggplotly(graf_tendencia)

```

Crecimiento de la población privada de la libertad femenina 

```{r tasa crecimiento femenina, echo = FALSE,  warning = FALSE, message=FALSE}

MPPtimeseries <- ts(ppl_gen$mujeres, frequency=12, start=c(1991,1))

autoplot(as.zoo(diff(log(MPPtimeseries))), geom = "line") + ylab("tasa de crecimiento- PPL femenina") + xlab("Periodo") + theme(aspect.ratio=1/2) -> graf_crecimiento
graf_crecimiento
ggsave("tasa_crec_femenina.png")
# ggplotly(graf_crecimiento)

```

```{r tasa de crecimiento descompuesta - femenina, echo = FALSE,  warning = FALSE, message=FALSE }

DeltaMPP <- decompose(diff(log(MPPtimeseries)))

tendencia <- as.zoo(DeltaMPP$trend)
aleatorio <- as.zoo(DeltaMPP$random)
estacional <- as.zoo(DeltaMPP$seasonal)

autoplot(merge(tendencia,estacional, aleatorio), geom = "line") + ylab("tasa de crecimiento - descomposición") + xlab("Periodo") -> graf_tendencia

graf_tendencia     
# ggplotly(graf_tendencia)
ggsave("tasa_crec_femenina.png")
```
Como se evidencia que componente aleatorio no tiene varianza constante se genera componente lineal, el análisis pertinente es por sindicados y condenados, pues es el que se considera en el resto de la tesis. 

```{r variacion_intermensual}
# Población sindicada a serie de tiempo por situación
ppl_sitjur  %>% spread(key = "categoria", value = valor) -> ppl_situacion 
# Serie de tiempo de población total
TPPtimeseries <- ts(ppl_situacion$total, frequency=12, start=c(1991,1))
# Serie de tiempo de población sindicada 
SPPtimeseries <- ts(ppl_situacion$condenados, frequency=12, start=c(1991,1))
# Serie de tiempo de población condenada
CPPtimeseries <- ts(ppl_situacion$sindicados, frequency=12, start=c(1991,1))

# Ajustar a zoo, para poder hacer gráfica
Total <- as.zoo(diff(TPPtimeseries))
Sindicados <- as.zoo(diff(SPPtimeseries))
Condenados <- as.zoo(diff(CPPtimeseries))

# Gráficar crecimient de las tres
autoplot(merge(Total, Sindicados, Condenados), geom = "line")  + ylab("N° de personas") + xlab("Periodo") +theme_minimal() -> graf_var
graf_var
ggsave("variacion_intermensual.png")
```
```{r variacion_mensual_total_desc}
# Descomponer variación intermensual
DeltaTPP <- decompose(Total)

# Asignar
tendencia <- as.zoo(DeltaTPP$trend)
aleatorio <- as.zoo(DeltaTPP$random)
estacional <- as.zoo(DeltaTPP$seasonal)

# Generar gráfica 
autoplot(merge(tendencia,estacional, aleatorio), geom = "line") + ylab("N° de personas") + xlab("Periodo") + theme_minimal()  -> graf_tendencia_tpp
graf_tendencia_tpp
ggsave("variacion_mensual_total_desc.png")
```

```{r variacion_mensual_sindicados_desc}
# Descomponer variación intermensual
DeltaSPP <- decompose(Sindicados)

# Asignar
tendencia <- as.zoo(DeltaSPP$trend)
aleatorio <- as.zoo(DeltaSPP$random)
estacional <- as.zoo(DeltaSPP$seasonal)

# Generar gráfica
autoplot(merge(tendencia,estacional, aleatorio), geom = "line") + ylab("N° de personas, sindicados") + xlab("Periodo") + theme_minimal() -> graf_tendencia_spp

# gráfica
graf_tendencia_spp
ggsave("variacion_mensual_sindicados_desc.png")
```
```{r variacion_mensual_condenados_desc}
# Descomponer variación intermensual
DeltaCPP <- decompose(Condenados)

# Asignar
tendencia <- as.zoo(DeltaCPP$trend)
aleatorio <- as.zoo(DeltaCPP$random)
estacional <- as.zoo(DeltaCPP$seasonal)

# Generar gráfica
autoplot(merge(tendencia,estacional, aleatorio), geom = "line") + ylab("N° de personas, condenados") + xlab("Periodo") +theme_minimal()-> graf_tendencia_cpp

# gráfica
graf_tendencia_cpp
ggsave("variacion_mensual_condenados_desc.png")
```

# Procesos ARIMA

Los procesos ARMA son procesos aleatorios de la forma 

<center> $Y_t = \gamma Y_{t-1} + \gamma_2 Y_{t-2} ... + \epsilon + \theta_1\epsilon_{t-1}$<center>

Aunque el termino $\epsilon$ no tiene necesariamente una distribución normal, por el resto de documento se asumirá una distribución normal con media $\mu$ y varianza $\sigma²$, a menos que se especifique lo contrario. 

Los procesos ARIMA resultan al considerar una serie de la forma: 

<center> $Y_t = \alpha +  Y_{t-1}$ <center>

Tal que el proceso $Y_t - Y_{t-1}$ es un proceso ARMA.

Una primera aproximación a la proyección de poblaciones carcelarias será validar si es posible modelar el proceso como un proceso ARIMA. Con este propósito presentamos las funciones de autocorrelación y autocorrelación parcial de la población total.


```{r ACF, echo = FALSE}
ppl_sitjur %>% dplyr::filter(categoria == "total", !(is.na(valor))) -> ppl_total
ppl_total <- ppl_total$valor
ts_total <- ts(ppl_total, start = 1991, frequency = 12)
#plot(diff(diff(ts_total), lag = 12))
#acf2(diff(diff(ts_total), lag = 12), max.lag = 60, details = FALSE)
plot(acf(diff(diff(ts_total), lag = 12), lag.max = 60, plot = FALSE),main = " ")
#dev.copy(png,'AFC_var_pob_total_desesta.png')
#dev.off()
pacf_total <- plot(pacf(diff(diff(ts_total), lag = 12), lag.max = 60, plot = FALSE),main = " ")
#dev.copy(png,'PAFC_var_pob_total_desesta.png')
#dev.off()
```

```{r ACF_var_pob, fig.height=11, fig.width=7}
## Crear variables
# Población carcelaria total
ppl_sitjur %>% dplyr::filter(categoria == "total", !(is.na(valor))) -> ppl_total
ppl_total <- ppl_total$valor
ts_total <- ts(ppl_total, start = 1991, frequency = 12)
# Sindicados
ppl_sitjur %>% dplyr::filter(categoria == "sindicados", !(is.na(valor))) -> ppl_sindi
ppl_sindi <- ppl_sindi$valor
ts_sindi <- ts(ppl_sindi, start = 1991, frequency = 12)
# Condenados
ppl_sitjur %>% dplyr::filter(categoria == "condenados", !(is.na(valor))) -> ppl_conde
ppl_conde <- ppl_conde$valor
ts_conde <- ts(ppl_conde, start = 1991, frequency = 12)
error = 2/sqrt(length(ppl_conde))

## Población total
# Calcular acf y pacf
acf_total <- as.data.frame(acf2(diff(diff(ts_total), lag = 12), max.lag = 60))
# Gráfica acf total
acf_total %>% ggplot() + geom_bar(aes(x = c(1:60), y = ACF), stat = "identity", fill = "steelblue") + scale_x_continuous(breaks = c(12,24,36,48,60)) + xlab("LAG") + ggtitle("ACF Población total") + ylim(c(-0.55,0.55)) + geom_hline(aes(yintercept = error), colour = "royalblue", linetype="dashed") + geom_hline(aes(yintercept = -error), colour = "royalblue", linetype="dashed") + theme_minimal()-> graf_acf_total
# Gráfica pacf total  
acf_total %>% ggplot() + geom_bar(aes(x = c(1:60), y = PACF), stat = "identity", fill = "steelblue") + scale_x_continuous(breaks = c(12,24,36,48,60)) + xlab("LAG") + ggtitle("PACF Población total") + ylim(c(-0.55,0.55)) + geom_hline(aes(yintercept = error), colour = "royalblue", linetype="dashed") + geom_hline(aes(yintercept = -error), colour = "royalblue", linetype="dashed") + theme_minimal() -> graf_pacf_total

## Población sindicada
# Calcular acf y pacf
acf_sindi <- as.data.frame(acf2(diff(diff(ts_sindi), lag = 12), max.lag = 60))
# Gráfica acf sindicados
acf_sindi %>% ggplot() + geom_bar(aes(x = c(1:60), y = ACF), stat = "identity", fill = "steelblue1") + scale_x_continuous(breaks = c(12,24,36,48,60)) + xlab("LAG") + ggtitle("ACF Población sindicada") + ylim(c(-0.55,0.55)) + geom_hline(aes(yintercept = error), colour = "royalblue", linetype="dashed") + geom_hline(aes(yintercept = -error), colour = "royalblue", linetype="dashed") + theme_minimal() -> graf_acf_sindi
# Gráfica pacf sindicados 
acf_sindi %>% ggplot() + geom_bar(aes(x = c(1:60), y = PACF), stat = "identity", fill = "steelblue1") + scale_x_continuous(breaks = c(12,24,36,48,60)) + xlab("LAG") + ggtitle("PACF Población sindicada") + ylim(c(-0.55,0.55)) + geom_hline(aes(yintercept = error), colour = "royalblue", linetype="dashed") + geom_hline(aes(yintercept = -error), colour = "royalblue", linetype="dashed") + theme_minimal() -> graf_pacf_sindi

## Población condenada
# Calcular acf y pacf
acf_conde <- as.data.frame(acf2(diff(diff(ts_conde), lag = 12), max.lag = 60))
# Gráfica acf condenados
acf_conde %>% ggplot() + geom_bar(aes(x = c(1:60), y = ACF), stat = "identity", fill = "steelblue2") + scale_x_continuous(breaks = c(12,24,36,48,60)) + xlab("LAG") + ggtitle("ACF Población condenada") + ylim(c(-0.55,0.55)) + geom_hline(aes(yintercept = error), colour = "royalblue", linetype="dashed") + geom_hline(aes(yintercept = -error), colour = "royalblue", linetype="dashed") + theme_minimal() -> graf_acf_conde

# Gráfica pacf condenados
acf_conde %>% ggplot() + geom_bar(aes(x = c(1:60), y = PACF), stat = "identity", fill = "steelblue2") + scale_x_continuous(breaks = c(12,24,36,48,60)) + xlab("LAG") + ggtitle("PACF Población condenada") + ylim(c(-0.55,0.55)) + geom_hline(aes(yintercept = error), colour = "royalblue", linetype="dashed") + geom_hline(aes(yintercept = -error), colour = "royalblue", linetype="dashed") + theme_minimal() -> graf_pacf_conde

#png(file = 'ACF_var_pob.png', height = 750, width = 500, res = 85)
ACF_var_pob <- grid.arrange(graf_acf_total, graf_pacf_total,graf_acf_sindi, graf_pacf_sindi,graf_acf_conde, graf_pacf_conde, ncol = 2)

ACF_var_pob
#dev.copy(png,'ACF_var_pob')
#dev.off()
```

Las funciones de autocorrelación y correlación cruzada, de $Y_t - Y_{t - 1} $ muestran: 

* La función de autocorrelación decae, y la función de autocorrelación parcial también decae, sugiriendo un ARMA. 
* La función de autocorrelación se encuetra sobre las dos desviaciones estándar, sugiriendo que son significativas.
* La función de autocorrelación tiene un único pico en el periodo doce, la función de autocorrelación parcial decae lentamente, sugiriendo un MA(1)

En estas condiciones podemos ajustar un ARIMA (1,1,1,0,0,1)

```{r estima_arima, echo = FALSE, include = TRUE}
arima_total <- sarima(ts_total,1,1,1,0,0,1, S = 12, details = FALSE)
```

Todos los parámetros del modelo tienen un p_value que sugiere que son significativos, excepto por la constante. Sin embargo, la autocorrelación del periodo dos sugiere que podemos estimar un ARIMA (1,1,1,0,0,2)

```{r estima_arima_2, echo = FALSE, include = TRUE}
sarima_total_2 <- sarima(ts_total,1,1,1,0,0,2, S = 12, details = FALSE)
```

El nuevo término SA2 resulta siginicativo y presenta criterios de información de valor más pequeño, lo que implica que el modelo ARIMA (1,1,1,0,0,2) resulta más apropiado que el modelo ARIMA (1,1,1,0,0,1). Proyecciones de la población carcelaria del modelo ARIMA (1,1,1,0,0,2) se presentan a continuación: 

```{r pry_arima_2, echo = FALSE, include = TRUE}
forecast <- sarima.for(ts_total,n.ahead = 36, 1,1,1,0,0,2, S = 12)
```

```{r ACF_sin, echo = FALSE, include = FALSE}
ppl_sitjur %>% dplyr::filter(categoria == "sindicados", !(is.na(valor))) -> ppl_sin
ppl_sin <- ppl_sin$valor
ts_sin <- ts(ppl_sin, start = 1991, frequency = 12)
# plot(diff(diff(ts_total), lag = 12))
# acf2(diff(diff(ts_total), lag = 12), max.lag = 60, details = FALSE)
plot (acf(diff(diff(ts_sin), lag = 12), lag.max = 60, plot = FALSE),main = "AFC Variación de la población sindicada desestacionalizado")
plot(pacf(diff(diff(ts_sin), lag = 12), lag.max = 60, plot = FALSE),main = "PAFC Variación de la población sindicada desestacionalizado")
```

Se presenta proyección de la población sindicada: 

```{r pry_arima_sin, echo = FALSE, include = TRUE}
forecast <- sarima.for(ts_sin,n.ahead = 36, 1,1,1,0,0,1, S = 12)
```

```{r ACF_con, echo = FALSE, include = FALSE}
ppl_sitjur %>% dplyr::filter(categoria == "condenados", !(is.na(valor))) -> ppl_con
ppl_con <- ppl_con$valor
ts_con <- ts(ppl_con, start = 1991, frequency = 12)
# plot(diff(diff(ts_total), lag = 12))
# acf2(diff(diff(ts_total), lag = 12), max.lag = 60, details = FALSE)
acf <- plot (acf(diff(diff(ts_con), lag = 12), lag.max = 60, plot = FALSE),main = "AFC Variación de la población condenada desestacionalizado")
plot(pacf(diff(diff(ts_con), lag = 12), lag.max = 60, plot = FALSE),main = "PAFC acf Variación de la población condenada desestacionalizado")
```

Se presenta proyección de la población condenada: 

```{r pry_arima_con, echo = FALSE, include = TRUE}
forectast <- sarima.for(ts_con,n.ahead = 36, 1,1,1,0,0,1, S = 12)
```

 Limitaciones de los modelos ARIMA en proyección de poblaciones carcelarias

Aunque es posible seguir analizando modelos ARIMA hasta encontrar el que presente mejores criterios de información, detendremos el analisis en este punto, para centrarnos en las limitaciones del enfoque. 

1. La serie de población carcelarias incluye, por lo menos,  dos series de tiempo con un comportamiento diferente: La población condenada y la población sindicada. Estos procesos, son en principio procesos autoregresivos, donde además se podría intuir el error no es independiente (como en la población total).
2. Los shocks en el sistema no son necesariamente estables en el tiempo. Las variaciones en los parámetros del modelo dependen de variables exógenas, como la cantidad de personas que ingresan al sistema y la dureza de las penas.
3. Los intervalos de confianza crecen rápidamente pues el modelo se ve afectado fuertemente por cambios en el nivel.
4. Puesto que el modelo supone unos parámetros fijos no da cuenta de la influencia de variables exógenas en el crecimiento de la población carcelaria.

```{r var, echo = TRUE, include = TRUE}
#####Modelos VAR
# ts_sincon <- cbind (diff(ts_sin), diff(ts_con))
# VARselect(ts_sincon, lag.max=9, type="const")
# ts_sincon_mod <- VAR(ts_sincon,p = 1)
# forecast_var <- predict(ts_sincon_mod, n.ahead = 60)
# ts_sincon_mod
# forecast_var
# 
# # Cite packages 
# if(nchar(system.file(package="astsa"))) citation("astsa")
```

# Documento tesis

## Estimaciones 

### Población total

```{r Estimación pob total}
### Total 111002
png(file = 'Arima_total_111002.png', height = 750, width = 500, res = 85)
arima_total_1 <- sarima(ts_total,1,1,1,0,0,2, S = 12, details = FALSE)
dev.off()

### Total 111001
png(file = 'Arima_total_111001.png', height = 750, width = 500, res = 85)
arima_total_2 <- sarima(ts_total,1,1,1,0,0,1, S = 12, details = FALSE)
dev.off()

auto.arima(ts_total)
### Total Auto Arima
png(file = 'Arima_total_321002.png', height = 750, width = 500, res = 85)
arima_total_3 <- sarima(ts_total,3,2,1,0,0,2, S = 12, details = FALSE)
dev.off()

auto.arima(ts_total, ic = "aic")
### Total 121002
png(file = 'Arima_total_121002.png', height = 750, width = 500, res = 85)
arima_total_4 <- sarima(ts_total,1,2,1,0,0,2, S = 12, details = FALSE)
dev.off()

Indicadores <- matrix(c(arima_total_1$AIC,arima_total_1$BIC,arima_total_2$AIC,arima_total_2$BIC,arima_total_3$AIC,arima_total_3$BIC,arima_total_4$AIC,arima_total_4$BIC),ncol = 2)

AIC_total <- AIC(arima_total_1$fit,arima_total_2$fit, arima_total_3$fit,arima_total_4$fit)
BIC_total <- BIC(arima_total_1$fit,arima_total_2$fit, arima_total_3$fit,arima_total_4$fit)

Indicadores_df <- cbind(c("(1,1,1,0,0,2)","(1,1,1,0,0,1)","(3,2,1,0,0,2)","(1,2,1,0,0,2)"),round(AIC_total$AIC,2), round(BIC_total$BIC,2))

colnames(Indicadores_df) <- c("ORDEN","AIC","BIC")
#xtable(Indicadores_df)
#xtable(arima_total_4$ttable)
#xtable(arima_total_4$ttable, label = "parámetros_121002", caption = "Parámetros del modelo (1,2,1,0,0,2)")
```

### Población sindicada

```{r Estimación pob sindicada}
### sindicado 111001
png(file = 'Arima_sindi_11101.png', height = 750, width = 500, res = 85)
arima_sindi_1 <- sarima(ts_sindi,1,1,1,0,0,1, S = 12, details = FALSE)
dev.off()

### sindicado 211001
png(file = 'Arima_sindi_211001.png', height = 750, width = 500, res = 85)
arima_sindi_2 <- sarima(ts_sindi,2,1,1,0,0,1, S = 12, details = FALSE)
dev.off()

auto.arima(ts_sindi, ic = "aic")
### sindicado Auto Arima
png(file = 'Arima_sindi_012001.png', height = 750, width = 500, res = 85)
arima_sindi_3 <- sarima(ts_sindi,0,1,2,0,0,1, S = 12, details = FALSE)
dev.off()

### Total 121002
png(file = 'Arima_sindi_011000.png', height = 750, width = 500, res = 85)
arima_sindi_4 <- sarima(ts_sindi,0,1,1,0,0,0, S = 12, details = FALSE)
dev.off()

AIC_sindi <- AIC(arima_sindi_1$fit,arima_sindi_2$fit, arima_sindi_3$fit,arima_sindi_4$fit)
BIC_sindi <- BIC(arima_sindi_1$fit,arima_sindi_2$fit, arima_sindi_3$fit,arima_sindi_4$fit)

Indicadores_df_sindi <- cbind(c("(1,1,1,0,0,1)","(2,1,1,0,0,1)","(0,1,2,0,0,1)","(0,1,1,0,0,0)"),round(AIC_sindi$AIC,2), round(BIC_sindi$BIC,2))

colnames(Indicadores_df_sindi) <- c("ORDEN","AIC","BIC")
xtable(Indicadores_df_sindi)
#xtable(arima_total_4$ttable)
xtable(arima_sindi_3$ttable, label = "parámetros_sindi_011001", caption = "Parámetros del modelo (0,1,1,0,0,1)")
```

### Población condenada 

```{r Estimación pob condenada}
### condenada 111001
png(file = 'Arima_conde_111001.png', height = 750, width = 500, res = 85)
arima_conde_1 <- sarima(ts_conde,1,1,1,0,0,1, S = 12, details = FALSE)
dev.off()

### condenado 211001
png(file = 'Arima_conde_211001.png', height = 750, width = 500, res = 85)
arima_conde_2 <- sarima(ts_conde,2,1,1,0,0,1, S = 12, details = FALSE)
dev.off()

auto.arima(ts_conde, ic = "aic")
### condenado Auto Arima
png(file = 'Arima_conde_012001.png', height = 750, width = 500, res = 85)
arima_conde_3 <- sarima(ts_conde,0,1,2,0,0,1, S = 12, details = FALSE)
dev.off()

### Total 121002
png(file = 'Arima_conde_011000.png', height = 750, width = 500, res = 85)
arima_conde_4 <- sarima(ts_conde,0,1,1,0,0,0, S = 12, details = FALSE)
dev.off()

AIC_conde <- AIC(arima_conde_1$fit,arima_conde_2$fit, arima_conde_3$fit,arima_conde_4$fit)
BIC_conde <- BIC(arima_conde_1$fit,arima_conde_2$fit, arima_conde_3$fit,arima_conde_4$fit)

Indicadores_df_conde <- cbind(c("(1,1,1,0,0,1)","(2,1,1,0,0,1)","(0,1,1,0,0,1)","(0,1,1,0,0,0)"),round(AIC_conde$AIC,2), round(BIC_conde$BIC,2))

colnames(Indicadores_df_conde) <- c("ORDEN","AIC","BIC")
xtable(Indicadores_df_conde)
#xtable(arima_total_4$ttable)
xtable(arima_conde_1$ttable, label = "parámetros_conde_111001", caption = "Parámetros del modelo (1,1,1,0,0,1)")
```

## Ajuste de errores

### Población total

```{r ajustar series a dic 2016}
#se retira enero de 2017
ts_total <- ts(ts_total[1:312], start = c(1991,1), frequency = 12)
ts_sindi <- ts(ts_sindi[1:312], start = c(1991,1), frequency = 12)
ts_conde <- ts(ts_conde[1:312], start = c(1991,1), frequency = 12)
```


```{r errores pob total}
# Ejecutar mejor modelo
arima_total_4 <- sarima(ts_total,1,2,1,0,0,2, S = 12, details = FALSE)
# Estraer residuales
residuales_arima_total_4 <- arima_total_4$fit$residuals
# Filtrar contra un umbral
residuales_out_arima_total_4 <- 1*(abs(residuales_arima_total_4)>(sqrt(arima_sindi_3$fit$sigma2)*3))

#Transformar a matriz Dummy
outliers <- t(as.data.frame(residuales_out_arima_total_4))
outliersdiag <-t(outliers)%*%as.matrix(outliers)*diag(dim(outliers)[2])
A <- outliersdiag
outliersdiagdummy <- as.matrix(A[,A[row(A)==col(A)]==1])

# Generar nuevo modelo
arima_total_4_dummy <- sarima(ts_total,1,2,1,0,0,2, S = 12, xreg = outliersdiagdummy , details = FALSE)

# seleccionar el mejor modelo con los nuevos datos
arima_select <- auto.arima(ts_total,ic = "aic", xreg = outliersdiagdummy)

png(file = 'Arima_total_211200Dummy.png', height = 750, width = 500, res = 85) 
arima_total_4_dummy <- sarima(ts_total,2,1,1,2,0,0, S = 12, xreg = outliersdiagdummy , details = FALSE)
dev.off()

arima_total_4_dummystats <- stats::arima(x = ts_total, order = c(2, 1, 1), seasonal = list(order = c(2, 0, 0), period = 12), xreg = outliersdiagdummy , include.mean = TRUE, optim.control = list(trace = 1))

pry_dummy = matrix(0,36,dim(outliersdiagdummy)[2])

forecast_dummy_total <- predict(arima_total_4_dummystats, n.ahead = 36, newxreg = pry_dummy)
```

### Población sindicada
```{r errores pob sindicada}
# Ejecutar mejor modelo
arima_sindi_3 <- sarima(ts_sindi,0,1,2,0,0,1, S = 12, details = FALSE)
# Estraer residuales
residuales_arima_sindi_3 <- arima_sindi_3$fit$residuals
# Filtrar contra un umbral
residuales_out_arima_sindi_3 <- 1*(abs(residuales_arima_sindi_3)>(sqrt(arima_sindi_3$fit$sigma2)*3))

#Transformar a matriz Dummy
outliers <- t(as.data.frame(residuales_out_arima_sindi_3))
outliersdiag <-t(outliers)%*%as.matrix(outliers)*diag(dim(outliers)[2])
A <- outliersdiag
outliersdiagdummy <- as.matrix(A[,A[row(A)==col(A)]==1])

# Generar nuevo modelo
arima_sindi_3_dummy <- sarima(ts_sindi,0,1,2,0,0,1, S = 12, xreg = outliersdiagdummy , details = FALSE)

# seleccionar el mejor modelo con los nuevos datos
arima_select <- auto.arima(ts_sindi,ic = "aic", xreg = outliersdiagdummy)

png(file = 'Arima_sindi_012001Dummy.png', height = 750, width = 500, res = 85)
arima_sindi_3_dummy <- sarima(ts_sindi,0,1,2,0,0,1, S = 12, xreg = outliersdiagdummy , details = FALSE)
dev.off()

arima_sindi_3_dummystats <- stats::arima(x = ts_sindi, order = c(0, 1, 2), seasonal = list(order = c(0, 0, 1), period = 12), xreg = outliersdiagdummy , include.mean = TRUE, optim.control = list(trace = 1))

pry_dummy = matrix(0,36,dim(outliersdiagdummy)[2])

forecast_dummy_sindi <- predict(arima_sindi_3_dummystats, n.ahead = 36, newxreg = pry_dummy)
```

### Población condenada
```{r errores pob condenada}
# Ejecutar mejor modelo
arima_conde_1 <- sarima(ts_sindi,1,1,1,0,0,1, S = 12, details = FALSE)
# Estraer residuales
residuales_arima_conde_1 <- arima_conde_1$fit$residuals
# Filtrar contra un umbral
residuales_out_arima_conde_1 <- 1*(abs(residuales_arima_sindi_3)>(sqrt(arima_conde_1$fit$sigma2)*3))

#Transformar a matriz Dummy
outliers <- t(as.data.frame(residuales_out_arima_conde_1))
outliersdiag <-t(outliers)%*%as.matrix(outliers)*diag(dim(outliers)[2])
A <- outliersdiag
outliersdiagdummy <- as.matrix(A[,A[row(A)==col(A)]==1])

# Generar nuevo modelo
arima_conde_1_dummy <- sarima(ts_conde,1,1,1,0,0,1, S = 12, xreg = outliersdiagdummy , details = FALSE)

# seleccionar el mejor modelo con los nuevos datos
arima_select <- auto.arima(ts_conde,ic = "aic", xreg = outliersdiagdummy)

arima_conde_1_dummy <- sarima(ts_conde,1,1,1,0,0,1, S = 12, xreg = outliersdiagdummy , details = FALSE)

arima_conde_1_dummystats <- stats::arima(x = ts_conde, order = c(1, 1, 1), seasonal = list(order = c(0, 0, 1), period = 12), xreg = outliersdiagdummy , include.mean = TRUE, optim.control = list(trace = 1))

residuales_arima_conde_11 <- arima_conde_1_dummy$fit$residuals
# Filtrar contra un umbral
residuales_out_arima_conde_1 <- (abs(residuales_arima_conde_11)>2000)*1

#Transformar a matriz Dummy
outliers <- t(as.data.frame(residuales_out_arima_conde_1))
outliersdiag <-t(outliers)%*%as.matrix(outliers)*diag(dim(outliers)[2])
A <- outliersdiag
outliersdiagdummy1 <- as.matrix(A[,A[row(A)==col(A)]==1])
outliersdiagdummys <- cbind(outliersdiagdummy1,outliersdiagdummy)

# Generar nuevo modelo
arima_conde_1_dummy1 <- sarima(ts_conde,1,1,1,0,0,1, S = 12, xreg = outliersdiagdummys , details = FALSE)

# seleccionar el mejor modelo con los nuevos datos
arima_select <- auto.arima(ts_conde,ic = "aic", xreg = outliersdiagdummys)

png(file = 'Arima_conde_111001Dummy.png', height = 750, width = 500, res = 85)
arima_conde_1_dummy <- sarima(ts_conde,1,1,1,0,0,1, S = 12, xreg = outliersdiagdummys , details = FALSE)
dev.off()

arima_conde_1_dummystats <- stats::arima(x = ts_conde, order = c(1, 1, 1), seasonal = list(order = c(0, 0, 1), period = 12), xreg = outliersdiagdummys , include.mean = TRUE, optim.control = list(trace = 1))

# Pryectar 
pry_dummy = matrix(0,36,dim(outliersdiagdummys)[2])

forecast_dummy_conde <- predict(arima_conde_1_dummystats, n.ahead = 36, newxreg = pry_dummy)
```

## Proyecciones

### Población total

```{r gráfica forecast total} 
# Proyección
forecast <- sarima.for(ts_total,n.ahead = 36, 1,2,1,0,0,2, S = 12)
# data frame
forecast_frame <- data.frame(Proyección=as.matrix(forecast$pred),Error=as.matrix(forecast$se), date=as.Date(as.yearmon(time(forecast$pred)))) %>% mutate(lim_sup = Proyección+Error, lim_inf = Proyección - Error)
#data histórica
hist_frame <- data.frame(Historico=as.matrix(ts_total), date=as.Date(as.yearmon(time(ts_total))))
# ggplot
ggplot() + geom_ribbon(data = forecast_frame, aes(x = date, ymin = Proyección - 2*Error, ymax = Proyección+2*Error, fill = "2 sd"  ), fill = "grey90")  + geom_ribbon(data = forecast_frame, aes(x = date, ymin = Proyección -Error, ymax = Proyección+Error,fill = "1 sd"  ), fill = "grey80") + geom_line(data = forecast_frame, aes(x = date, y = Proyección, colour = "Proyección")) + geom_line(data = hist_frame, aes(x = date, y = Historico, colour = "Histórico")) + xlab("Periodo") + ylab("Población carcelaria total") + theme_minimal() + theme(legend.title=element_blank()) -> graf_pry_total_4
graf_pry_total_4
ggsave("graf_pry_total_4.png")
```

```{r gráfica forecast total dummy} 
# Proyección
forecast <- forecast_dummy_total
# data frame
forecast_frame <- data.frame(Proyección=as.matrix(forecast$pred),Error=as.matrix(forecast$se), date=as.Date(as.yearmon(time(forecast$pred)))) %>% mutate(lim_sup = Proyección+Error, lim_inf = Proyección - Error)
#data histórica
hist_frame <- data.frame(Historico=as.matrix(ts_total), date=as.Date(as.yearmon(time(ts_total))))
# ggplot
ggplot() + geom_ribbon(data = forecast_frame, aes(x = date, ymin = Proyección - 2*Error, ymax = Proyección+2*Error, fill = "2 sd"  ), fill = "grey90")  + geom_ribbon(data = forecast_frame, aes(x = date, ymin = Proyección -Error, ymax = Proyección+Error,fill = "1 sd"  ), fill = "grey80") + geom_line(data = forecast_frame, aes(x = date, y = Proyección, colour = "Proyección")) + geom_line(data = hist_frame, aes(x = date, y = Historico, colour = "Histórico")) + xlab("Periodo") + ylab("Población carcelaria total") + theme_minimal() + theme(legend.title=element_blank()) -> graf_pry_total_4
graf_pry_total_4
ggsave("graf_pry_total_4_dummy.png")
```

### Población sindicada
```{r gráfica forecast sindicados} 
# Proyección debe usar versión 1.8
forecast <- sarima.for(ts_sindi,n.ahead = 36, 0,1,2,0,0,1, S = 12 )
# data frame
forecast_frame <- data.frame(Proyección=as.matrix(forecast$pred),Error=as.matrix(forecast$se), date=as.Date(as.yearmon(time(forecast$pred)))) %>% mutate(lim_sup = Proyección+Error, lim_inf = Proyección - Error)
#data histórica
hist_frame <- data.frame(Historico=as.matrix(ts_sindi), date=as.Date(as.yearmon(time(ts_sindi))))
# ggplot
ggplot() + geom_ribbon(data = forecast_frame, aes(x = date, ymin = Proyección - 2*Error, ymax = Proyección+2*Error, fill = "2 sd"  ), fill = "grey90")  + geom_ribbon(data = forecast_frame, aes(x = date, ymin = Proyección -Error, ymax = Proyección+Error,fill = "1 sd"  ), fill = "grey80") + geom_line(data = forecast_frame, aes(x = date, y = Proyección, colour = "Proyección")) + geom_line(data = hist_frame, aes(x = date, y = Historico, colour = "Histórico")) + xlab("Periodo")+ ylab("Población carcelaria sindicada") + theme_minimal() + theme(legend.title=element_blank()) -> graf_pry_total_3
graf_pry_total_3
ggsave("graf_pry_sindi_3.png")
```

```{r gráfica forecast sindicados dummy} 
# Proyección debe usar versión 1.8
forecast <- forecast_dummy_sindi
# data frame
forecast_frame <- data.frame(Proyección=as.matrix(forecast$pred),Error=as.matrix(forecast$se), date=as.Date(as.yearmon(time(forecast$pred)))) %>% mutate(lim_sup = Proyección+Error, lim_inf = Proyección - Error)
#data histórica
hist_frame <- data.frame(Historico=as.matrix(ts_sindi), date=as.Date(as.yearmon(time(ts_sindi))))
# ggplot
ggplot() + geom_ribbon(data = forecast_frame, aes(x = date, ymin = Proyección - 2*Error, ymax = Proyección+2*Error, fill = "2 sd"  ), fill = "grey90")  + geom_ribbon(data = forecast_frame, aes(x = date, ymin = Proyección -Error, ymax = Proyección+Error,fill = "1 sd"  ), fill = "grey80") + geom_line(data = forecast_frame, aes(x = date, y = Proyección, colour = "Proyección")) + geom_line(data = hist_frame, aes(x = date, y = Historico, colour = "Histórico")) + xlab("Periodo")+ ylab("Población carcelaria sindicada") + theme_minimal() + theme(legend.title=element_blank()) -> graf_pry_total_3
graf_pry_total_3
ggsave("graf_pry_sindi_3_dummy.png")
```

### Población condenada
```{r gráfica forecast condenados} 
# Proyección
forecast <- sarima.for(ts_conde,n.ahead = 36, 1,1,1,0,0,1, S = 12)
# data frame
forecast_frame <- data.frame(Proyección=as.matrix(forecast$pred),Error=as.matrix(forecast$se), date=as.Date(as.yearmon(time(forecast$pred)))) %>% mutate(lim_sup = Proyección+Error, lim_inf = Proyección - Error)
#data histórica
hist_frame <- data.frame(Historico=as.matrix(ts_conde), date=as.Date(as.yearmon(time(ts_conde))))
# ggplot
ggplot() + geom_ribbon(data = forecast_frame, aes(x = date, ymin = Proyección - 2*Error, ymax = Proyección+2*Error, fill = "2 sd"  ), fill = "grey90")  + geom_ribbon(data = forecast_frame, aes(x = date, ymin = Proyección -Error, ymax = Proyección+Error,fill = "1 sd"  ), fill = "grey80") + geom_line(data = forecast_frame, aes(x = date, y = Proyección, colour = "Proyección")) + geom_line(data = hist_frame, aes(x = date, y = Historico, colour = "Histórico")) + xlab("Periodo")+ ylab("Población carcelaria condenada") + theme_minimal()+ theme(legend.title=element_blank()) -> graf_pry_conde_1
graf_pry_conde_1
ggsave("graf_pry_conde_1.png")
```

```{r gráfica forecast condenados dummy} 
# Proyección
forecast <- forecast_dummy_conde
# data frame
forecast_frame <- data.frame(Proyección=as.matrix(forecast$pred),Error=as.matrix(forecast$se), date=as.Date(as.yearmon(time(forecast$pred)))) %>% mutate(lim_sup = Proyección+Error, lim_inf = Proyección - Error)
#data histórica
hist_frame <- data.frame(Historico=as.matrix(ts_conde), date=as.Date(as.yearmon(time(ts_conde))))
# ggplot
ggplot() + geom_ribbon(data = forecast_frame, aes(x = date, ymin = Proyección - 2*Error, ymax = Proyección+2*Error, fill = "2 sd"  ), fill = "grey90")  + geom_ribbon(data = forecast_frame, aes(x = date, ymin = Proyección -Error, ymax = Proyección+Error,fill = "1 sd"  ), fill = "grey80") + geom_line(data = forecast_frame, aes(x = date, y = Proyección, colour = "Proyección")) + geom_line(data = hist_frame, aes(x = date, y = Historico, colour = "Histórico")) + xlab("Periodo")+ ylab("Población carcelaria condenada") + theme_minimal()+ theme(legend.title=element_blank()) -> graf_pry_conde_1
graf_pry_conde_1
ggsave("graf_pry_conde_1_dummy.png")
```

# Método de ratio Correlation.

```{r descargar datos rc, fig.height=10, fig.width=7}
# url <- "https://www.dropbox.com/s/94oblxtlc8anlk1/PRY_POB_NAL_DANE_EDAD.csv?dl=1"
# destfile <- "POB_NAL_DAN_EDAD.csv"
# curl_download(url, destfile)
```

```{r POB_NAL_EDAD, fig.height=11, fig.width=7}
# pob_nal_dane_edad = read.csv("POB_NAL_DAN_EDAD.csv",header = TRUE,sep = ",",stringsAsFactors=FALSE)
# 
# pob_nal_dane_edad %<>% gather(Rango_edad, Poblacion, -Año, -Grupos.de.edad) %>% spread(Grupos.de.edad, Poblacion)
# 
# pob_nal_dane_edad %<>% dplyr::filter(Año>1990)
# 
# pob_nal_dane_edad$Rango_edad<- gsub("X","",pob_nal_dane_edad$Rango_edad)
# pob_nal_dane_edad$Rango_edad<- gsub("\\.","-",pob_nal_dane_edad$Rango_edad)
# pob_nal_dane_edad$Rango_edad<- gsub("0-4","00-04",pob_nal_dane_edad$Rango_edad)
# pob_nal_dane_edad$Rango_edad<- gsub("400-044","40-44",pob_nal_dane_edad$Rango_edad)
# pob_nal_dane_edad$Rango_edad<- gsub("5-9","05-09",pob_nal_dane_edad$Rango_edad)
# 
# pob_nal_dane_edad %>% ggplot(aes(x=Año, y = Total/1000000, fill = Rango_edad)) + geom_area(stat="identity") + theme_minimal() + ylab("Proyecciones de población nacional (MM)") + scale_fill_manual(values = colorRampPalette(brewer.pal(12, "Paired"))(17)) + theme(legend.position="none") -> pob_total_edad_stack
# 
# pob_nal_dane_edad %>% ggplot(aes(x=Año, y = Total/1000000, colour = Rango_edad)) + geom_line() + theme_minimal() + ylab("Proyecciones de población nacional (MM)") + scale_colour_manual(values = colorRampPalette(brewer.pal(12, "Paired"))(17)) + theme(legend.position="none") -> pob_total_edad
# 
# ### Crear columna de participación 
# 
# pob_nal_dane_edad %<>% group_by(Año) %>% summarise(Totales_año = sum(Total)) %>% right_join(pob_nal_dane_edad, by = NULL) %>% mutate (Participacion= Total/Totales_año*100) 
# 
# pob_nal_dane_edad %>% ggplot(aes(x=Año, y = Participacion, fill = Rango_edad)) + geom_area(stat="identity") + theme_minimal() + ylab("Proyecciones de población nacional (%)") + scale_fill_manual(values = colorRampPalette(brewer.pal(12, "Paired"))(17)) -> pob_total_edad_stack_part
# 
# pob_nal_dane_edad %>% ggplot(aes(x=Año, y = Participacion, colour = Rango_edad)) + geom_line() + theme_minimal() + ylab("Proyecciones de población nacional (%)") + scale_colour_manual(values = colorRampPalette(brewer.pal(12, "Paired"))(17)) -> pob_total_edad_part
# 
# # Generar gráfica
# #png(file = 'POB_NAL_EDAD.png', height = 850, width = 600, res = 85)
# POB_NAL_EDAD <- grid.arrange(pob_total_edad_stack, pob_total_edad_stack_part,pob_total_edad, pob_total_edad_part, ncol = 2)
# POB_NAL_EDAD
# #dev.off()
```

```{r REG_POB_NAL_EDAD, fig.height=10, fig.width=7}
# # Cargar datos 
# pob_nal_dane_edad = read.csv("POB_NAL_DAN_EDAD.csv",header = TRUE,sep = ",",stringsAsFactors=FALSE)
# 
# # cambiar estructura donde el genero es columna y los gruposde edad es fila
# pob_nal_dane_edad %<>% gather(Rango_edad, Poblacion, -Año, -Grupos.de.edad) %>% spread(Grupos.de.edad, Poblacion)
# 
# pob_nal_dane_edad %<>% dplyr::filter(Año>1990)
# 
# # Corregir titulos de rango etario
# pob_nal_dane_edad$Rango_edad<- gsub("X","",pob_nal_dane_edad$Rango_edad)
# pob_nal_dane_edad$Rango_edad<- gsub("\\.","-",pob_nal_dane_edad$Rango_edad)
# pob_nal_dane_edad$Rango_edad<- gsub("0-4","00-04",pob_nal_dane_edad$Rango_edad)
# pob_nal_dane_edad$Rango_edad<- gsub("400-044","40-44",pob_nal_dane_edad$Rango_edad)
# pob_nal_dane_edad$Rango_edad<- gsub("5-9","05-09",pob_nal_dane_edad$Rango_edad)
# 
# # Población DANE por edad
# pob_nal_dane_edad %>% dplyr::select(Año, Rango_edad, Total) %>% tidyr::spread(Rango_edad, Total) -> pob_dane_edad
# 
# # Acumular rangos etarios que se trabajan acumulados
# Menor_14 <-apply(pob_dane_edad[,2:4],1,sum)
# Mayor_60 <- apply(pob_dane_edad[,16:18],1,sum)
# 
# # Crear arreglo de regresores
# Regresores <- cbind(Menor_14,pob_dane_edad[,5:15],Mayor_60)
# 
# # Calcular población total
# Pob_total <- apply(Regresores,1,sum)
# 
# # Población total en mayo de cada año
# ppl_sitjur %>% dplyr::filter(categoria =="total", mes == 5, !is.na(valor)) %>% dplyr::select(valor, anio) -> pob_inpec_total
# 
# # Calcular tasa de encarcelamiento
# registros <- dim(pob_inpec_total)[1]
# tasa_encar <- pob_inpec_total[,1]/Pob_total[1:registros]
# 
# 
# 
# # Guardar modelo de regresión
# tasa_regresores <- cbind(tasa_encar = pob_inpec_total[,1],Regresores[1:registros,]) 
# 
# # Salvar
# write.table(tasa_regresores,"tasa_regresores.csv",sep=",",row.names = FALSE)
```

```{r REGRESION}
# tasa_regresores <- read.table("tasa_regresores.csv", sep = ",", header = TRUE)
# 
# ddist <- datadist(tasa_regresores)
# options(datadst = "ddist")
# 
# reg <- lm(tasa_encar ~ -1 + X15.19 + X20.24  + X20.24 + X25.29 + X30.34 + X35.39 + X40.44 + X45.49 + X50.54 + X55.59 + Mayor_60, data = tasa_regresores)
# summary(reg)
# 
# step(reg,direction="backward")
```






